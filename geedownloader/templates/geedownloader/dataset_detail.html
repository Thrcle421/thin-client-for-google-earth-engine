{% load static %}
{% load custom_filters %}
<!DOCTYPE html>
<html>

<head>
    <title>{{ metadata.title }} - Dataset Details</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        #map {
            height: 400px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .metadata-section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .download-form {
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .task-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            display: none;
        }

        .variable-description {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .bands-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .band-item {
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px 15px;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
        }

        .band-item:hover {
            background-color: #e9ecef;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">Earth Engine Dataset Search</a>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Title and tags side by side - remove mb-4 margin -->
        <div class="row">
            <div class="col-md-8">
                <h2>{{ metadata.title }}</h2>
            </div>
            <div class="col-md-4">
                <!-- Remove top padding from metadata-section -->
                <div class="metadata-section" style="margin-top: 0; padding-top: 10px;">
                    <h4>Tags</h4>
                    <div class="mb-0">
                        {% for tag in metadata.properties.keywords %}
                        <span class="badge bg-secondary me-1">{{ tag }}</span>
                        {% endfor %}
                    </div>

                    <div id="tagsContainer" style="display: none;">
                        <h5>Additional Tags</h5>
                        <div id="datasetTags" class="mb-0"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Content row - add negative top margin to remove space -->
        <div class="row" style="margin-top: -15px;">
            <div class="col-md-8">
                <div class="metadata-section">
                    <h4>Description</h4>
                    <div id="datasetDescription">
                        {% if metadata.description %}
                        {{ metadata.description|safe }}
                        {% else %}
                        Loading description...
                        {% endif %}
                    </div>
                </div>

                <div class="metadata-section">
                    <h4>Dataset Information</h4>
                    <table class="table">
                        <tbody>
                            <tr>
                                <th>ID</th>
                                <td>{{ metadata.id }}</td>
                            </tr>
                            <tr>
                                <th>Name</th>
                                <td>{{ metadata.name }}</td>
                            </tr>
                            <tr>
                                <th>Type</th>
                                <td>{{ metadata.type }}</td>
                            </tr>
                            <tr>
                                <th>Title</th>
                                <td>{{ metadata.properties.title }}</td>
                            </tr>
                            <tr>
                                <th>Provider</th>
                                <td>
                                    {% if metadata.properties.provider_url %}
                                    <a href="{{ metadata.properties.provider_url }}" target="_blank">{{
                                        metadata.properties.provider }}</a>
                                    {% else %}
                                    {{ metadata.properties.provider }}
                                    {% endif %}
                                </td>
                            </tr>
                            <tr>
                                <th>Time Range</th>
                                <td>{{ metadata.start_time }} to {{ metadata.end_time }}</td>
                            </tr>
                            {% comment %}
                            <tr>
                                <th>Last Updated</th>
                                <td>{{ metadata.update_time }}</td>
                            </tr>
                            {% if metadata.properties.period is not None %}
                            <tr>
                                <th>Period</th>
                                <td>{{ metadata.properties.period }}</td>
                            </tr>
                            {% endif %}
                            {% endcomment %}
                        </tbody>
                    </table>
                </div>

                <div class="metadata-section">
                    <h4>Bands Information</h4>
                    <div class="bands-grid">
                        {% for band in metadata.bands %}
                        <div class="band-item">
                            {{ band.id }}
                        </div>
                        {% empty %}
                        <div class="band-item">
                            No band information available
                        </div>
                        {% endfor %}
                    </div>
                </div>

                {% if metadata.geometry %}
                <div class="metadata-section">
                    <h4>Coverage Area</h4>
                    <div id="coverage-map" style="height: 400px;"></div>
                </div>

                <script>
                    document.addEventListener('DOMContentLoaded', function () {
                        try {
                            const coverageGeometry = {{ metadata.geometry| safe
                        }};
                    if (!coverageGeometry) {
                        document.getElementById('coverage-map').innerHTML = '<p class="text-center">No coverage data available</p>';
                        return;
                    }

                    const coverageMap = L.map('coverage-map');
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(coverageMap);

                    const geoJsonLayer = L.geoJSON(coverageGeometry, {
                        style: {
                            color: '#ff7800',
                            weight: 2,
                            opacity: 0.65
                        }
                    }).addTo(coverageMap);

                    coverageMap.fitBounds(geoJsonLayer.getBounds());
                    } catch (error) {
                        console.error("Error displaying map:", error);
                        document.getElementById('coverage-map').innerHTML = '<p class="text-center">Error displaying coverage area</p>';
                    }
                });
                </script>
                {% else %}
                <div class="metadata-section">
                    <h4>Coverage Area</h4>
                    <p class="text-center">Coverage area information not available for this dataset.</p>
                </div>
                {% endif %}

                <div class="download-form">
                    <h4>Download Data</h4>
                    <form id="downloadForm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="variable" class="form-label">Variable/Band</label>
                                    <select class="form-control" id="variable" required>
                                        <option value="">Select a variable...</option>
                                    </select>
                                    <div id="variableDescription" class="variable-description"></div>
                                </div>
                                <div class="mb-3">
                                    <label for="startDate" class="form-label">Start Date</label>
                                    <input type="date" class="form-control" id="startDate" required lang="en">
                                </div>
                                <div class="mb-3">
                                    <label for="endDate" class="form-label">End Date</label>
                                    <input type="date" class="form-control" id="endDate" required lang="en">
                                    <small class="form-text text-muted">Single date or date range supported</small>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="scale" class="form-label">Scale (meters)</label>
                                    <input type="number" class="form-control" id="scale" value="1000" required>
                                    <small class="form-text text-muted">Resolution in meters</small>
                                </div>
                                <div class="mb-3">
                                    <label for="format" class="form-label">Export Format</label>
                                    <select class="form-control" id="format">
                                        <option value="GeoTIFF">GeoTIFF</option>
                                        <option value="TFRecord">TFRecord</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="folder_name" class="form-label">Google Drive Folder Name</label>
                                    <input type="text" class="form-control" id="folder_name" value="GEE-Downloads">
                                    <small class="form-text text-muted">Files will be saved to this folder in your
                                        Google Drive</small>
                                </div>
                                <div class="mb-3">
                                    <label for="ee_project_id" class="form-label">Earth Engine Project ID</label>
                                    <input type="text" class="form-control" id="ee_project_id"
                                        placeholder="Enter your Project ID">
                                </div>
                                <div class="mb-3">
                                    <button type="button" class="btn btn-secondary"
                                        onclick="reinitializeEarthEngine()">Reinitialize Earth Engine</button>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Download Method</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="downloadMethod"
                                            id="driveMethod" value="drive" checked>
                                        <label class="form-check-label" for="driveMethod">
                                            Google Drive Export (for large datasets)
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="downloadMethod"
                                            id="localMethod" value="local">
                                        <label class="form-check-label" for="localMethod">
                                            Direct Download (smaller datasets)
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Select Region on Map</label>
                            <div id="map"></div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="startDownload()">Start Download</button>
                    </form>

                    <div id="taskStatus" class="task-status alert">
                        <h5 class="alert-heading">Download Status</h5>
                        <p id="taskMessage"></p>
                        <div class="progress mb-2" style="display: none;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar">
                            </div>
                        </div>
                        <div id="downloadLink" style="display: none;">
                            <a href="#" class="btn btn-success mt-3" target="_blank">Download File</a>
                        </div>
                        <div id="driveInfo" class="mt-3" style="display: none;">
                            <p>Your export has been started and is being processed by Google Earth Engine.</p>
                            <p>The file will be available in your Google Drive folder once processing is complete.</p>
                            <p><strong>Folder:</strong> <span id="driveFolderName"></span></p>
                            <p><strong>Filename:</strong> <span id="driveFileName"></span></p>
                            <div class="alert alert-info">
                                <p><strong>Note:</strong> Processing will continue even if you close this page or if the
                                    session expires.</p>
                                <p>You can check your Google Drive folder directly to see when your files are ready.</p>
                                <p><a href="https://drive.google.com/drive/my-drive"
                                        class="btn btn-sm btn-outline-primary" target="_blank">Open Google Drive</a></p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-4">
                    <!-- Right sidebar content if needed -->
                </div>
            </div>
        </div>

        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
        <script>
            // Initialize map
            const map = L.map('map').setView([0, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

            // Initialize drawing layer
            const drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Add drawing controls
            const drawControl = new L.Control.Draw({
                edit: {
                    featureGroup: drawnItems
                },
                draw: {
                    polygon: true,
                    rectangle: true,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    polyline: false
                }
            });
            map.addControl(drawControl);

            // Handle drawing events
            map.on('draw:created', function (e) {
                drawnItems.clearLayers();
                drawnItems.addLayer(e.layer);
            });

            // Load dataset variables
            async function loadVariables() {
                try {
                    console.log('Fetching variables...');

                    // Get project ID
                    const projectId = document.getElementById('ee_project_id').value.trim();

                    // Build URL with project ID
                    let apiUrl = '/api/dataset/{{ metadata.id }}/variables/';
                    if (projectId) {
                        apiUrl += `?project_id=${encodeURIComponent(projectId)}`;
                    }

                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    console.log('Received data:', data);

                    // Check if there are errors
                    if (data.error) {
                        console.error('API returned error:', data.error);

                        // Update variable description to show error
                        const variableDescription = document.getElementById('variableDescription');
                        if (variableDescription) {
                            variableDescription.textContent = 'Error retrieving data variables: ' + data.error;
                            variableDescription.style.display = 'block';
                            variableDescription.className = 'variable-description text-danger';
                        }

                        // Add default option
                        const select = document.getElementById('variable');
                        if (select) {
                            select.innerHTML = '<option value="default">Default Band (Error)</option>';
                        }

                        return;
                    }

                    // Check if data.variables exists and is an array
                    if (!data.variables) {
                        console.error('Error: data.variables is undefined');
                        data.variables = [];
                    }

                    if (!Array.isArray(data.variables)) {
                        console.error('Error: data.variables is not an array:', data.variables);
                        data.variables = Array.isArray(data.variables) ? data.variables : [];
                    }

                    // Display dataset description
                    const descElement = document.getElementById('datasetDescription');
                    console.log('Current description text:', descElement ? descElement.textContent.trim() : 'Element not found');
                    console.log('API description:', data.description);

                    if (data.description && descElement) {
                        // If API returned a description and element exists, and current state is loading, show API's description
                        if (descElement.textContent.trim() === 'Loading description...') {
                            console.log('Updating description with API data');
                            descElement.textContent = data.description;
                        } else {
                            console.log('Keeping existing description');
                        }
                    } else {
                        console.log('No description from API or element not found');
                    }

                    // Display tags information
                    if (data.tags && Array.isArray(data.tags) && data.tags.length > 0) {
                        const tagsContainer = document.getElementById('datasetTags');
                        tagsContainer.innerHTML = '';
                        data.tags.forEach(function (tag) {
                            const tagElem = document.createElement('span');
                            tagElem.className = 'badge bg-secondary me-1';
                            tagElem.textContent = tag;
                            tagsContainer.appendChild(tagElem);
                        });
                        document.getElementById('tagsContainer').style.display = 'block';
                    }

                    // Update bands information table
                    const bandsTableBody = findBandsTable();
                    if (bandsTableBody && data.variables && data.variables.length > 0) {
                        console.log('Found bands table, updating with:', data.variables);
                        updateBandsTable(bandsTableBody, data.variables);
                    } else {
                        console.log('No band information found to display or table not found');
                    }

                    // Function: Find bands information table
                    function findBandsTable() {
                        console.log('Searching for bands container...');
                        // Find all "Bands Information" headings
                        const sections = document.querySelectorAll('.metadata-section');
                        for (let i = 0; i < sections.length; i++) {
                            const headings = sections[i].querySelectorAll('h4');
                            for (let j = 0; j < headings.length; j++) {
                                if (headings[j].textContent.includes('Bands Information')) {
                                    console.log('Found Bands Information section');
                                    const bandsGrid = sections[i].querySelector('.bands-grid');
                                    if (bandsGrid) {
                                        console.log('Found bands grid container');
                                        return bandsGrid;
                                    }
                                }
                            }
                        }
                        console.error('Bands information container not found');
                        return null;
                    }

                    // Function: Update bands table
                    function updateBandsTable(bandsContainer, variables) {
                        // Clear container
                        bandsContainer.innerHTML = '';

                        // Add information for each band
                        variables.forEach(function (band) {
                            const bandItem = document.createElement('div');
                            bandItem.className = 'band-item';

                            const id = band.id || '';
                            bandItem.innerHTML = `<strong>${id}</strong>`;

                            bandsContainer.appendChild(bandItem);
                        });

                        // If no band information, show a notice
                        if (variables.length === 0) {
                            const noDataItem = document.createElement('div');
                            noDataItem.className = 'band-item';
                            noDataItem.innerHTML = 'No band information available';
                            bandsContainer.appendChild(noDataItem);
                        }
                    }

                    // Handle variable selection dropdown
                    const select = document.getElementById('variable');
                    select.innerHTML = '<option value="">Select a variable...</option>';

                    if (!data.variables || data.variables.length === 0) {
                        console.log('No variables found, adding default option');
                        const option = document.createElement('option');
                        option.value = 'default';
                        option.textContent = 'Default Band';
                        select.appendChild(option);

                        document.getElementById('variableDescription').textContent = 'No band information available for this dataset';
                        document.getElementById('variableDescription').style.display = 'block';
                    } else {
                        console.log('Adding variables to select:', data.variables);
                        data.variables.forEach(function (band) {
                            const option = document.createElement('option');
                            option.value = band.id || '';
                            option.textContent = band.id || '';

                            // Extract description and units
                            let description = band.description || '';
                            let units = band.units || '';
                            let dataType = '';
                            let dimensions = '';
                            let crs = band.crs || '';
                            let crsTransform = band.crs_transform || '';

                            // Process data type
                            if (band.data_type) {
                                if (typeof band.data_type === 'object') {
                                    dataType = band.data_type.precision || '';
                                } else {
                                    dataType = band.data_type;
                                }
                            }

                            // Process dimensions
                            if (band.dimensions && Array.isArray(band.dimensions) && band.dimensions.length >= 2) {
                                dimensions = `${band.dimensions[0]} x ${band.dimensions[1]}`;
                            } else {
                                dimensions = band.dimensions || '';
                            }

                            // Set data attributes
                            option.setAttribute('data-description', description);
                            option.setAttribute('data-units', units);
                            option.setAttribute('data-data-type', dataType);
                            option.setAttribute('data-dimensions', dimensions);
                            option.setAttribute('data-crs', crs);
                            option.setAttribute('data-crs-transform', crsTransform);

                            select.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Error loading variables:', error);
                    console.error('Error stack:', error.stack);

                    // Set default option
                    const select = document.getElementById('variable');
                    select.innerHTML = '<option value="">Select a variable...</option>';
                    const option = document.createElement('option');
                    option.value = 'default';
                    option.textContent = 'Default Band';
                    select.appendChild(option);

                    document.getElementById('variableDescription').textContent = 'Error loading band information: ' + error.message;
                    document.getElementById('variableDescription').style.display = 'block';
                }
            }

            // Load temporal info
            async function loadTemporalInfo() {
                try {
                    // Get project ID
                    const projectId = document.getElementById('ee_project_id').value.trim();

                    // Build URL with project ID
                    let apiUrl = `/dataset/temporal-info/?dataset_id={{ metadata.id }}`;
                    if (projectId) {
                        apiUrl += `&project_id=${encodeURIComponent(projectId)}`;
                    }

                    const response = await fetch(apiUrl);
                    const data = await response.json();

                    console.log('Temporal info:', data);

                    // Set default date - use current date
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);

                    const defaultStartDate = yesterday.toISOString().split('T')[0];
                    const defaultEndDate = today.toISOString().split('T')[0];

                    const startDateInput = document.getElementById('startDate');
                    const endDateInput = document.getElementById('endDate');

                    // Set default value
                    startDateInput.value = defaultStartDate;
                    endDateInput.value = defaultEndDate;

                    if (data.start_date && data.end_date) {
                        console.log(`Setting date range: ${data.start_date} to ${data.end_date}`);
                        // Set limits
                        startDateInput.min = data.start_date;
                        startDateInput.max = data.end_date;
                        endDateInput.min = data.start_date;
                        endDateInput.max = data.end_date;

                        // If current value is outside valid range, set to dataset's start and end date
                        if (startDateInput.value < data.start_date || startDateInput.value > data.end_date) {
                            startDateInput.value = data.start_date;
                        }

                        if (endDateInput.value < data.start_date || endDateInput.value > data.end_date) {
                            endDateInput.value = data.end_date;
                        }
                    } else {
                        console.log('No temporal info available, using default dates');
                    }
                } catch (error) {
                    console.error('Error loading temporal info:', error);
                    // Set default date
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);

                    document.getElementById('startDate').value = yesterday.toISOString().split('T')[0];
                    document.getElementById('endDate').value = today.toISOString().split('T')[0];
                }
            }

            // Variable selection processing
            document.getElementById('variable').addEventListener('change', function (event) {
                const selectedOption = event.target.selectedOptions[0];
                const description = selectedOption.getAttribute('data-description');
                const units = selectedOption.getAttribute('data-units');
                const dataType = selectedOption.getAttribute('data-data-type');
                const dimensions = selectedOption.getAttribute('data-dimensions');
                const crs = selectedOption.getAttribute('data-crs');
                const crsTransform = selectedOption.getAttribute('data-crs-transform');

                const descElement = document.getElementById('variableDescription');
                if (description || units || dataType || dimensions || crs || crsTransform) {
                    const info = [];
                    if (description) info.push(description);
                    if (units) info.push('Units: ' + units);
                    if (dataType) info.push('Data Type: ' + dataType);
                    if (dimensions) info.push('Dimensions: ' + dimensions);
                    if (crs) info.push('CRS: ' + crs);
                    if (crsTransform) info.push('CRS Transform: ' + crsTransform);

                    descElement.textContent = info.join(' | ');
                    descElement.style.display = 'block';
                } else {
                    descElement.style.display = 'none';
                }
            });

            // Start download
            async function startDownload() {
                if (drawnItems.getLayers().length === 0) {
                    alert('Please select a region on the map');
                    return false;
                }

                const form = document.getElementById('downloadForm');

                // Check if variable is selected
                if (!form.variable.value) {
                    alert('Please select a variable');
                    return false;
                }

                // Check if project ID is provided
                const projectId = document.getElementById('ee_project_id').value.trim();
                if (!projectId) {
                    alert('Please enter your Earth Engine Project ID');
                    return false;
                }

                // Validate project ID format
                if (projectId.indexOf('517222506229') !== -1) {
                    // This appears to be an incorrect numeric ID
                    alert('Your project ID appears to be incorrect. Please use the format "ee-yourname" instead of a numeric ID.');
                    return false;
                }

                // Suggest the working project ID if needed
                if (!projectId.startsWith('ee-')) {
                    if (!confirm(`Your project ID "${projectId}" doesn't follow the expected format (should usually start with "ee-"). Continue anyway?`)) {
                        return false;
                    }
                }

                const data = {
                    dataset_id: '{{ metadata.id }}',
                    variable: form.variable.value,
                    start_date: form.startDate.value,
                    end_date: form.endDate.value,
                    scale: parseInt(form.scale.value),
                    format: form.format.value,
                    region: JSON.stringify(drawnItems.toGeoJSON()),
                    folder_name: form.folder_name.value,
                    project_name: projectId  // Add project ID parameter
                };

                const downloadMethod = document.querySelector('input[name="downloadMethod"]:checked').value;
                const endpoint = downloadMethod === 'drive' ? '/download/' : '/download-local/';

                try {
                    // Show waiting status
                    const statusDiv = document.getElementById('taskStatus');
                    const messageDiv = document.getElementById('taskMessage');
                    statusDiv.className = 'task-status alert alert-info';
                    statusDiv.style.display = 'block';
                    messageDiv.textContent = 'Processing your download request...';
                    document.getElementById('downloadLink').style.display = 'none';

                    if (downloadMethod === 'drive') {
                        statusDiv.querySelector('.progress').style.display = 'block';
                    } else {
                        statusDiv.querySelector('.progress').style.display = 'none';
                    }

                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify(data)
                    });

                    const result = await response.json();

                    if (response.ok) {
                        if (downloadMethod === 'drive') {
                            // Google Drive export - start polling for task status
                            showTaskStatus(result.task_id);
                        } else {
                            // Local download - display download link
                            showDownloadLink(result.url, result.filename);
                        }
                    } else {
                        showError(result.error || 'Download failed');
                    }
                } catch (error) {
                    showError('Error starting download: ' + error.message);
                }

                return false;
            }

            // Display download link
            function showDownloadLink(url, filename) {
                const statusDiv = document.getElementById('taskStatus');
                const messageDiv = document.getElementById('taskMessage');
                const downloadLinkDiv = document.getElementById('downloadLink');
                const downloadLinkA = downloadLinkDiv.querySelector('a');

                statusDiv.className = 'task-status alert alert-success';
                messageDiv.textContent = 'Your download is ready!';

                downloadLinkA.href = url;
                downloadLinkA.download = filename;
                downloadLinkA.textContent = `Download ${filename}`;
                downloadLinkDiv.style.display = 'block';

                // Auto-start download
                window.open(url, '_blank');
            }

            // Show task status
            function showTaskStatus(taskId) {
                console.log('Starting status monitoring for task:', taskId);
                const statusDiv = document.getElementById('taskStatus');
                const messageDiv = document.getElementById('taskMessage');
                const progressBar = statusDiv.querySelector('.progress');
                const progressBarInner = progressBar.querySelector('.progress-bar');
                const driveInfo = document.getElementById('driveInfo');

                // Store task ID in a data attribute for debugging
                statusDiv.dataset.taskId = taskId;

                statusDiv.className = 'task-status alert alert-info';
                statusDiv.style.display = 'block';
                messageDiv.textContent = 'Export task started...';
                progressBar.style.display = 'block';

                // Start polling task status
                pollTaskStatus(taskId);

                // Show the Google Drive info section
                driveInfo.style.display = 'block';

                // Set folder name and update Google Drive link
                const folderName = document.getElementById('folder_name').value.trim() || 'GEE-Downloads';
                document.getElementById('driveFolderName').textContent = folderName;

                // Update Google Drive link to point directly to the folder if possible
                const driveLink = driveInfo.querySelector('a[href*="drive.google.com"]');
                if (driveLink) {
                    // Encode the folder name for the search query
                    const encodedFolderName = encodeURIComponent(`title = "${folderName}"`);
                    driveLink.href = `https://drive.google.com/drive/search?q=${encodedFolderName}`;
                    driveLink.textContent = `Open "${folderName}" in Google Drive`;
                }
            }

            // Poll task status
            async function pollTaskStatus(taskId) {
                if (!taskId) {
                    console.error('No task ID provided for polling');
                    updateTaskStatus({ status: 'FAILED', error: 'No task ID available' });
                    return;
                }

                try {
                    console.log('Polling status for task:', taskId);

                    // Get the project ID
                    const projectId = document.getElementById('ee_project_id').value.trim();

                    // Use safer URL construction with project ID
                    const url = `/task-status/${encodeURIComponent(taskId)}/?project_id=${encodeURIComponent(projectId)}`;
                    console.log('Fetching from URL:', url);

                    const response = await fetch(url);

                    if (!response.ok) {
                        console.error('Task status response not OK:', response.status, response.statusText);

                        // Check if we got redirected to login page (authentication timeout)
                        if (response.status === 302 || response.type === 'opaqueredirect') {
                            showError('Authentication session expired. Please reload the page and re-authenticate with Earth Engine.');
                            return;
                        }

                        throw new Error(`HTTP error ${response.status}`);
                    }

                    // Check content type to ensure we're getting JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        console.error('Response is not JSON:', contentType);
                        showError('Session expired. Please reload the page and try again.');
                        return;
                    }

                    // Get response as text first for debugging
                    const rawText = await response.text();

                    // Check if the response seems to be HTML instead of JSON
                    if (rawText.trim().startsWith('<!DOCTYPE') || rawText.trim().startsWith('<html')) {
                        console.error('Received HTML instead of JSON');
                        showError('Authentication session expired. Please reload the page and re-authenticate with Earth Engine.');
                        return;
                    }

                    console.log('Raw response text:', rawText);

                    // Try to parse as JSON
                    let data;
                    try {
                        data = JSON.parse(rawText);
                        console.log('Parsed task status response:', data);
                    } catch (parseError) {
                        console.error('Error parsing JSON response:', parseError);
                        throw new Error(`Invalid JSON response: ${rawText.substring(0, 100)}...`);
                    }

                    // Defensive programming: ensure data is an object
                    if (!data || typeof data !== 'object') {
                        console.error('Response is not an object:', data);
                        data = { status: 'FAILED', error: `Invalid response format: ${typeof data}` };
                    }

                    // Extract information directly with fallbacks to avoid errors
                    const statusInfo = {
                        status: (data.status || 'UNKNOWN').toString().toUpperCase(),
                        progress: parseInt(data.progress || 0, 10),
                        error: (data.error || 'Unknown error').toString(),
                        folder: data.folder || document.getElementById('folder_name').value,
                        filename: data.filename || ''
                    };

                    console.log('Status info extracted:', statusInfo);
                    updateTaskStatus(statusInfo);

                    // Show Google Drive folder information
                    if (statusInfo.folder) {
                        const driveInfo = document.getElementById('driveInfo');
                        const folderNameSpan = document.getElementById('driveFolderName');
                        const fileNameSpan = document.getElementById('driveFileName');

                        if (driveInfo && folderNameSpan && fileNameSpan) {
                            folderNameSpan.textContent = statusInfo.folder;
                            fileNameSpan.textContent = statusInfo.filename || 'Will be determined by Earth Engine';
                            driveInfo.style.display = 'block';
                        }
                    }

                    // Only continue polling if task is still in progress
                    if (statusInfo.status !== 'COMPLETED' &&
                        statusInfo.status !== 'FAILED' &&
                        statusInfo.status !== 'CANCELLED') {
                        console.log('Task still in progress, scheduling next poll');
                        setTimeout(() => pollTaskStatus(taskId), 5000);
                    } else {
                        console.log('Task completed or failed, stopping polling');
                    }
                } catch (error) {
                    console.error('Error polling task status:', error);
                    updateTaskStatus({
                        status: 'FAILED',
                        error: `Failed to poll task status: ${error.message}`
                    });
                }
            }

            // Update task status display
            function updateTaskStatus(data) {
                console.log('Updating UI with task status:', data);
                const statusDiv = document.getElementById('taskStatus');
                const messageDiv = document.getElementById('taskMessage');
                const progressBar = statusDiv.querySelector('.progress-bar');

                try {
                    // Ensure data has required properties and convert to appropriate types
                    const status = String(data.status || 'FAILED').toUpperCase();
                    const error = String(data.error || 'Unknown error');

                    // Ensure progress is a number between 0-100
                    let progress = 0;
                    if (data.progress !== undefined) {
                        progress = Number(data.progress);
                        if (isNaN(progress)) progress = 0;
                        if (progress < 0) progress = 0;
                        if (progress > 100) progress = 100;
                    }

                    console.log(`Status: ${status}, Progress: ${progress}, Error: ${error}`);

                    switch (status) {
                        case 'COMPLETED':
                            statusDiv.className = 'task-status alert alert-success';
                            messageDiv.textContent = 'Download completed! Check your Google Drive folder.';
                            progressBar.style.width = '100%';
                            break;
                        case 'FAILED':
                        case 'CANCELLED':
                            statusDiv.className = 'task-status alert alert-danger';
                            messageDiv.textContent = `Download failed: ${error}`;
                            break;
                        case 'RUNNING':
                            statusDiv.className = 'task-status alert alert-info';
                            progressBar.style.width = `${progress}%`;
                            messageDiv.textContent = `Export in progress: ${progress}%`;
                            break;
                        case 'READY':
                            statusDiv.className = 'task-status alert alert-info';
                            progressBar.style.width = `5%`;
                            messageDiv.textContent = 'Task submitted, waiting to start...';
                            break;
                        default:
                            statusDiv.className = 'task-status alert alert-info';
                            progressBar.style.width = `${progress}%`;
                            messageDiv.textContent = `Task status: ${status} (${progress}%)`;
                    }
                } catch (error) {
                    console.error('Error updating task status UI:', error);
                    statusDiv.className = 'task-status alert alert-danger';
                    messageDiv.textContent = 'Error updating task status: ' + error.message;
                    progressBar.style.width = '0%';
                }
            }

            // Show error message
            function showError(message) {
                const statusDiv = document.getElementById('taskStatus');
                const messageDiv = document.getElementById('taskMessage');
                const progressBar = statusDiv.querySelector('.progress');

                statusDiv.className = 'task-status alert alert-danger';
                statusDiv.style.display = 'block';
                messageDiv.innerHTML = `<strong>Error:</strong> ${message}`;
                progressBar.style.display = 'none';

                // If it's an authentication or session error, add reload button
                if (message && (message.toLowerCase().includes('session') || message.toLowerCase().includes('authentication'))) {
                    const reloadBtn = document.createElement('button');
                    reloadBtn.className = 'btn btn-primary mt-3';
                    reloadBtn.textContent = 'Reload Page';
                    reloadBtn.onclick = function () {
                        window.location.reload();
                    };
                    messageDiv.appendChild(document.createElement('br'));
                    messageDiv.appendChild(reloadBtn);

                    // Also add instructions for checking Google Drive directly
                    const driveInfo = document.createElement('div');
                    driveInfo.className = 'mt-3 alert alert-info';
                    driveInfo.innerHTML = `
                    <p><strong>Important:</strong> Even if the status check fails, your export task will continue processing in the background.</p>
                    <p>You can check your Google Drive folder directly to see if the file appears there.</p>
                    <p><a href="https://drive.google.com/drive/folders/0B0" class="btn btn-outline-primary" target="_blank">Open Google Drive</a></p>
                `;
                    messageDiv.appendChild(driveInfo);
                }

                // If it's a permission error, add more help information
                if (message && message.toLowerCase().includes('permission')) {
                    const helpDiv = document.createElement('div');
                    helpDiv.className = 'mt-3';
                    helpDiv.innerHTML = `
                    <p><strong>Permission Issue Solutions:</strong></p>
                    <ol>
                        <li>Make sure you have completed registration and verification in the <a href="https://code.earthengine.google.com/" target="_blank">Earth Engine Code Editor</a>.</li>
                        <li>Try accessing this dataset directly in the Earth Engine Code Editor.</li>
                        <li>Some datasets require special permissions or access requests. Please check the dataset documentation.</li>
                    </ol>
                `;
                    messageDiv.appendChild(helpDiv);
                }
            }

            // Initialize when page loads
            document.addEventListener('DOMContentLoaded', function () {
                // Restore project ID from localStorage
                const savedProjectId = localStorage.getItem('ee_project_id');
                if (savedProjectId) {
                    document.getElementById('ee_project_id').value = savedProjectId;
                    console.log("Restored project ID from localStorage:", savedProjectId);
                }

                // Set date picker language and format
                const dateInputs = document.querySelectorAll('input[type="date"]');
                dateInputs.forEach(input => {
                    input.lang = 'en';

                    // Add placeholder for older browsers
                    if (input.type !== 'date') {
                        input.placeholder = 'YYYY-MM-DD';
                    }
                });

                // Initialize date pickers
                flatpickr("#startDate", {
                    dateFormat: "Y-m-d",
                    allowInput: true,
                    locale: {
                        firstDayOfWeek: 1
                    }
                });

                flatpickr("#endDate", {
                    dateFormat: "Y-m-d",
                    allowInput: true,
                    locale: {
                        firstDayOfWeek: 1
                    }
                });

                loadVariables();
                loadTemporalInfo();
            });

            // Reinitialize Earth Engine Authentication
            async function reinitializeEarthEngine() {
                try {
                    const projectId = document.getElementById('ee_project_id').value.trim();
                    if (!projectId) {
                        alert('Please enter your Earth Engine Project ID');
                        return;
                    }

                    // Save project ID to localStorage
                    localStorage.setItem('ee_project_id', projectId);

                    const response = await fetch('/reinitialize-ee/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ project_id: projectId })
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        alert('Earth Engine authentication successful! You can now continue downloading data.');
                        // Refresh variables and temporal information
                        loadVariables();
                        loadTemporalInfo();
                    } else {
                        alert(`Authentication failed: ${result.message || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Authentication error:', error);
                    alert(`Error during authentication process: ${error.message}`);
                }
            }
        </script>
</body>

</html>